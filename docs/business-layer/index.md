# Business Objects
The main entities in pybiz applications are referred to as business objects. These are things like accounts, users, posts, and photo albums.

## Anatomy of a BizObject
All business objects inherit from the abstract base class, `BizObject`. Each declares fields and relationships, like a traditional ORM. For example, consider a domain model for music, including albums and tracks. We could represent this in Pybiz like this:

```python
from pybiz.biz import BizObject, Relationship
from pybiz.schema import Field, String, Int

class Album(BizObject):
    tracks = Relationship(lambda album: Track.album_id == album._id, many=True)
    name = String()
    artist = String()
    year = Int()

class Track(BizObject):
    album = Relationship(lambda track: Album._id == track.album_id)
    album_id = Field(private=True)
    title = String()
    lyrics = String()
    duration = Int()
```

Without any further work related to persistence, server protocol, or user interface, these classes are ready for use in fully-functional applications. In the following sections, we will discuss fields and relationships in detail.

## Fields
`Field` objects declare what elements of data are available on each `BizObject`. By default, every business object inherits an `_id` field. This is the only field required by pybiz itself. In the example above, `name`, `artist`, and `year` are all fields declared on the `Album` class.

Behind the scenes, pybiz gathers all fields declared on a `BizObject` class and creates a subclass of `pybiz.schema.Schema`. For example, the schema class generated for `Album` would be accessed via `Album.Schema`. In a nutshell, the internal responsibility of the schema is to perform casting and validation upon binding data to instance attributes.

For details on the implementation and capabilities of the `Schema` and `Field` classes, please refer to documentation for the `appyratus` project.

### Private Fields
When a `Field` is created with the `private` flag set, pybiz will _never_ include this key in the output generated by calling the `dump` defined on the base `BizObject` class. This is appropriate for confidential information or fields that exist for application-internal purposes only.

### Field Properties
When Python builds each `BizObject` class, it replaces each `Field` set on the class with a corresponding `FieldProperty` object. These properties behave distinctly when accessed as class attributes, as compared to instance attributes. When accessed on an instance, they return data. When accessed on the class in conditional expressions, they form `Predicate` objects for use in queries.

Here is an example:

```python
# accessing data through instance attribute
album = Album(name='Magical Mystery Tour', artist='The Beatles').save()
assert album.name == 'Magical Mystery Tour'

# creating a query predicate with the class attribute
queried_album = Album.query(Album.name == 'Magical Mystery Tour', first=True)
assert album._id == queried_album._id
```

### Implementation Notes
You can access the raw data dict, containing field values, through the `self.data` instance attribute; however, unless you know what you are doing, you should always modify field values through instance attributes.

Note that field data can be accessed through instance attributes or like items in a dict. That is to say,

```python
assert user.name is user['name']
```

## Relationships
Unlike fields, relationships define one or more "join" conditions that associate the host business object with one or more related business objects. In the example above, `Album.tracks` relates each album to a list of all its related `Track` objects.

### Joins
Here is an example of a one-to-many relationship with a single join:

```python
class Account(BizObject):
  """
  An account has many users.
  """
  users = Relationship(
    join=lambda acc: User.account_id == acc._id,
    many=True
  )
```

Here is an example of a many-to-many relationship, using a secondary join, which uses of the output of first join as input for the second:

```python
class Document(BizObject):
  """
  A document in a fictitous collaborative word processor app.
  """
  editors = Relationship(
    join=(
      lambda doc: UserDoc.document_id == doc._id,
      lambda ud: (User._id == ud.user_id) & (ud.role == 'editor')
    ),
    many=True
  )
```

### Private Relationships
In addition to declaring private fields, it is possible to declare private relationships. These relationships are excluded from output generated by calls to the `dump` method defined on the base `BizObject` class.

### Implementation Notes
You can access relationships delcared on a `BizObject` at runtime through the `relationships` class attribute. For example, consider the class,

```python
class Thing(BizObject):
  a = Relationship(...)
  b = Relationship(...)
```

This would give us:

```python
assert Thing.relationshps == {'a': Thing.a, 'b': Thing.b}
```

In addition, business objects loaded and managed by relationships are stored in `self.related`. To continue with the example above,

```python
if thing.a is a:  # note that `thing` is an instance object
  assert thing.related['a'] is a
```

Note that related business objects can be accessed through instance attributes _or_ like items in a dict. That is to say,

```python
assert user.friends is user['friends']
```

## CRUD Operations
The base `BizObject` class implements a range of CRUD methods, which internally delegate requests to a persistence layer.

### Creating
To create new business objects, simply instantiate a new `BizObject` and call `save`. Data can be passed into the constructor as a "data" dict argument or as individual custom keyword arguments. Here are some examples, which are all equivalent:

```python
user = User({'name': 'Daniel', 'age': 74}).save()
user = User({'name': 'Daniel'}, age=74).save()
user = User(name='Daniel', age=74).save()
```

Internally, pybiz interprets a call to `save` as a _create_ operation if the `_id` field is `None`; otherwise, it interprets it as an _update_ operation.

Note that the `save` method will recursively apply to all business objects currently loaded through a `Relationship` on the calling instance.

### Reading - Basic
At a basic level, you can fetch business objects by their ID's with two build-in class methods: `get` and `get_many`. Both of these allow you to specify which fields you want, both from the calling instance and the instances loaded through its relationships.

Suppose you wanted to fetch a user but only its "name" field. You could do this:

```python
user = User.get(1, {'name'})
```

Now suppose that the `User` class defines a "friends" relationship, which resolves to a list of other `User` instances and wanted only their names as well. You could do,

```python
user = User.get(1, {'name', 'friends.name'})
```

However, if you wanted _all_ fields from the "friends" relationship, you could use the Kleene star, as follows:

```python
user = User.get(1, {'name', 'friends.*'})
```

Finally, if only the name of the relationship itself is specified in the list of requested fields, then pybiz only fetches the `_id` field. Specifically,

```python
user = User.get(1, {'name', 'friends'})
```

The `get_many` method works in the same way, the only difference being that the first argument takes a set of ID\'s rather than a single one.

### Reading - Advanced
Use the `query` method when you need to find, say, a user by something other than an ID, like an e-mail addressd. It is similar to a SQL `select` statement. Instead of taking an ID, it takes a logical predicate as its first argument, which serves as the `where` clause.

At a high-level, there are two types of predicates in `pybiz`, conditional predicates and boolean predicates. Here are some examples of conditional predicates:

```python
is_young_enough = (User.age < 40)
has_name = (User.first_name == 'tuvok')
has_location = (User.planet.including('earth', 'vulcan'))
```

Conditional predicates can be combined in boolean expressions (to form boolean predicates) using `&` for "and" and `|` for "or".

Here is an example of a boolean predicate, composed of thee conditional predicates, defining a list of users "eligible" for some purpose in a fictitous app:

```python
eligible_users = ((has_name & has_location) | age_predicate)

#                    OR
#                  /    \
#    is_young_enough    AND
#                      /   \
#               has_name    has_location
```

Put into words,

> Any user young enough **OR** has both the right name **AND** right location.

Furthermore, you can use this and other predicates to write queries in business logic, insulated from changes to the underying persistence technology, like:

```python
users_to_invite = User.query(eligible_users, fields={'name', 'email'})
for user in users_to_invite:
  send_invite(user.email, message=f"{user.name.title()}, you're invited!")
```

#### Practical Example
Find a user by email address:

```python
user = User.query(User.email == 'seven.of.nine@gmail.com', first=True)
```

### Updating
Updating a `BizObject` is accomplished in the same way that _create_ is: namely, by calling `save`. This will only perform an _update_ (as opposed to a _create_) if and only if the `_id` field is not None.

Here is an example of updating a `User` business object:

```python
user = User(name='Daniel', age=74).save()
user.name = 'Lord Ruffus'
user.save()
```

When `save` is called, only modified field values are passed into the persistence layer for updating. You can access a set of modified field names through a `dirty` instance property. After calling `save`, the dirty set is cleared.

### Deleting
Deleting a BizObject is as easy as calling the `delete` instance method. Doing this marks all fields on the instance as `dirty` (that is, as unsaved) and sets the `_id` fields value to `None`.

```python
user.delete()
```

It is also possible to delete in batch, like:

```python
User.delete_many({1, 2, 3})
```

## Lazy Loading
By default, both fields and relationships are lazy loaded. This means that if you fetch a business object, specifying that you are only interested in field "foo" but then try to access an non-loaded field "bar", pybiz will fetch the remaining unloaded fields, including "bar".

The same principle applies to relationships. If you have a user object with a "friends" relationship that is not yet loaded, then accessing `user.friends` for the first time will execute the relationship, loading related business objects.

Lazy loading can be toggled by setting the `lazy` keyword argument in `Field` and `Relationship` declarations, for example:

```python
class User(BizObject):
  friends = Relationship(..., lazy=False)
  name = String(lazy=False)
```

Be careful not to trigger lazy loading accidentally while checking for the existence of related data. For example, doing

```python
if user.friends:
  do_something()
```

will cause the friends relationship to execute, loading all its data. This might not be what you want. Instead, if you just want to check if the relationship is or is not loaded, you shuld do:

```python
if user.has('friends'):
  do_something()
```

## Serialization
In the context of pybiz, serialization is the process of converting a business object into data structure, composed only of primitive types, which can then be written to a serialization format, like JSON, protocol buffers, etc. In pybiz, this process is called _dumping_.

### Dumping Business Objects
Each `BizObject` object inherits a `dump` method, which converts its fields and relationships _currently loaded_ into a plain Python `dict`. By default, relationships are included in the dump as nested dicts or lists of dicts; however, a side-loading format is also available.

The semantics of `dump` mirror the semantics of `get`, `get_many`, `query` and `load` in that specific fields of interest can be specified. Note that trying to dump unloaded fields or relationships will result in an exception, unless lazy loading is specified as a parameter to dump.

```python
# dump all loaded data by default
user.dump()

# dump specific fields
user.dump({'name', 'friends.name'})

# dump specific fields with lazy loading
user.dump({'name', 'friends.*'}, lazy=True)
```

## Magic methods
In some cases, it might be useful to declare the `Dao` or `Schema` object used by a business object at runtime. Normally, this is determined by a program manifest file (See: Configuration).

### DAO Override
#### XXX: DEPRECATED
In case your `Dao` class requires complex runtime initialization, you can override the `__dao__` method on your `BizObject` class. It must return either a `Dao` class or an instance thereof. This will override the corresponding binding declared in your manifest, provided you have one.

```python
@classmethod
def __dao__(cls):
  return MyDao()
```

### Schema Override
Whenever possible, you should declare fields as attributes on your `BizObject` classes; however, for whatever reason, it may be necessary for you to store `Schema` objects in an external module or package. If this is so, you can specify the schema at runtime by overriding `__schema__`.

For example:

```python
@classmethod
def __schema__(cls):
  return MySchema()
```

## Footnotes
### String Representation
When working with business objects in the shell, it is useful to see certain information at a glance. Currently, each business object will display its ID, ( or a '?' if null), along with an asterisk if there exists a dirty field. To remind you, a "dirty" field is one that has been modified since last save or load.

Here are some examples:
```python
# a new, unsaved object, where the question mark means "no ID"
user = User(name='Worf')
print(user)  # <User(?)*>

# a saved user with no dirty fields
user.save()
print(user)  # <User(1)>

# a saved user with a dirty "name" field
user.name = 'Commander Worf'
print(user)  # <User(1)*>

```
