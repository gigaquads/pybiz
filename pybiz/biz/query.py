import bisect

from functools import reduce
from typing import List, Dict, Set, Text, Type, Tuple

from appyratus.utils import DictUtils, DictObject

import pybiz.contrib.graphql as graphql

from pybiz.util.misc_functions import is_bizobj, is_sequence
from pybiz.constants import IS_BIZOBJ_ANNOTATION
from pybiz.schema import Schema, fields
from pybiz.predicate import Predicate

from .field_property import FieldProperty
from .order_by import OrderBy
from .biz_list import BizList
from .biz_attribute import BizAttributeProperty


class QueryExecutor(object):
    def execute(self, query: 'Query'):
        if query.params.where and len(query.params.where) > 1:
            predicate = reduce(lambda x, y: x & y, query.params.where)
        else:
            predicate = (query.biz_type._id != None)

        records = query.biz_type.get_dao().query(
            predicate=predicate,
            fields=query.params.fields,
            order_by=query.params.order_by,
            limit=query.params.limit,
            offset=query.params.offset,
        )

        targets = biz_type.BizList(biz_type(x) for x in records)
        return self._execute_recursive(query, targets).clean()

    def _execute_recursive(self, query: 'Query', sources: List['BizObject']):
        # the class whose relationships we are executing:
        biz_type = query.biz_type

        # now sort attribute names by their BizAttribute priority.
        ordered_items = []
        for biz_attr_name, sub_query in query.params.attributes.items():
            biz_attr = biz_type.attributes.by_name(biz_attr_name)
            bisect.insort(ordered_items, (biz_attr, sub_query))

        # execute each BizAttribute on each BizObject individually. a nice to
        # have would be a bulk-execution interface built built into the
        # BizAttribute base class
        for biz_attr, sub_query in ordered_items:
            if biz_attr.category == 'relationsihp':
                targets = sub_query.execute(
                    sources,
                    select=sub_query.params.fields,
                    where=sub_query.params.where,
                    order_by=sub_query.params.order_by,
                    limit=sub_query.params.limit,
                    offset=sub_query.params.offset,
                )
                # execute nested relationsihps and then zip each
                # source BizObject up with its corresponding target
                # BizObjects, as returned by the BizAttribute.
                self._execute_recursive(sub_query, targets)
                for source, target in zip(sources, targets):
                    setattr(source, k, target)
            else:
                for source in sources:
                    if sub_query:
                        value = sub_query.execute(source)
                    else:
                        value = biz_attr.execute(source)
                    setattr(source, biz_attr.name, value)

        return sources


class QueryPrinter(object):
    def print_query(self, query: 'AbstractQuery') -> None:
        """
        Just pretty print the query.
        """
        print(self.format_query(query))

    def format_query(self, query: 'AbstractQuery', indent=0) -> Text:
        """
        Return a pretty printed string of the query in Pybiz query langauge.
        """
        biz_type_name = query.biz_type.__name__

        # we collect all substrings of the final format string in three
        # different lists below. Formatting differs slightly for substrings
        # generated by recursive calls to this method, and this is why collect
        # them separarely here.
        pre_sub_query_substrs = []
        post_sub_query_substrs = []
        sub_query_substrs = []

        # target_names is a lexicographically sorted list of all
        # non-Relationship selectble attribute names on the target BizObject
        # class.
        target_names = []
        target_names += list(query.params.fields.keys() - {'_id', '_rev'})
        target_names += list(query.params.attributes.keys())
        target_names.sort()

        pre_sub_query_substrs.append(f'FROM {biz_type_name} SELECT')
        pre_sub_query_substrs.extend(f' - {k}' for k in target_names)

        # recursively render sub_queries corresponding to selected Relationships
        if query.params.sub_queries:
            for name, sub_query in sorted(query.params.attributes.items()):
                if isinstance(sub_query, Query):
                    sub_query_substr = self.format_query(sub_query, indent=indent+5)
                    sub_query_substrs.append(f'{" " * indent} - {name}: (')
                    sub_query_substrs.append(sub_query_substr)

        # render "where"-expression Predicates
        predicates = query.params.where
        if predicates:
            predicate = reduce(
                lambda x, y: x & y, query.params.where
            )
            post_sub_query_substrs.append(f'WHERE {predicate}')

        # render order by
        order_by = query.params.order_by
        if order_by:
            post_sub_query_substrs.append(
                'ORDER_BY (' + ', '.join(
                f'{x.key} {"DESC" if x.desc else "ASC"}'
                for x in order_by
            ) + ')')

        # render limit and offset
        offset = query.params.offset
        if offset is not None:
            post_sub_query_substrs.append(f'OFFSET {offset}')
        limit = query.params.limit
        if limit is not None:
            post_sub_query_substrs.append(f'LIMIT {limit}')

        # generate final format string
        fstr = '\n'.join(
            f'{" " * indent}{chunk}' for chunk in pre_sub_query_substrs
        )
        if sub_query_substrs:
            fstr += '\n' + '\n'.join(f'{chunk}' for chunk in sub_query_substrs)
        if post_sub_query_substrs:
            fstr += '\n' + '\n'.join(
                f'{" " * indent}{chunk}' for chunk in post_sub_query_substrs
            )

        return fstr


class QueryLoader(object):

    class Schema(Schema):
        alias = fields.String()
        limit = fields.Int(nullable=True)
        offset = fields.Int(nullable=True)
        order_by = fields.List(fields.String(), default=[])
        where = fields.List(fields.Dict(), nullable=True)
        target = fields.Nested({
            'type': fields.String(),
            'attributes': fields.Dict(default={}),
            'fields': fields.Dict(default={}),
        })

    def __init__(self):
        self._schema = QueryLoader.Schema()

    def dump(self, query):
        return {
            'alias': query.alias,
            'limit': query.params.limit,
            'offset': query.params.offset,
            'order_by': [x.dump() for x in query.params.order_by],
            'where': (
                [x.dump() for x in query.params.where] if
                query.params.where is not None
                else None
            ),
            'target': {
                'type': query.biz_type.__name__,
                'fields': query.params.fields,
                'attributes': {
                    k: self.dump(v) for k, v in query.params.attributes.items()
                }
            }
        }

    def load(self, biz_type, data):
        data, errors = self._schema.process(data)
        if errors:
            # TODO: raise custom exceptions
            raise ValueError(str(errors))

        sub_queries = []
        for v in data['sub_queries'].values():
            child_biz_type_name = v['target']['type']
            child_biz_type = biz_type.registry.types.biz[child_biz_type_name]
            sub_queries.append(self.load(child_biz_type, v))

        targets = sub_queries.copy()
        targets += list(data['target']['fields'].keys())
        targets += list(data['target']['attributes'].keys())

        order_by = [OrderBy.load(x) for x in data['order_by']]

        query = Query(biz_type=biz_type, alias=data['alias'])
        query.select(targets)
        query.order_by(order_by)
        query.limit(data['limit'])
        query.offset(data['offset'])

        if data['where']:
            query.where([
                Predicate.load(biz_type, x) for x in data['where']
            ])

        return query

    @classmethod
    def from_keys(
        cls, biz_type: Type['BizObject'], keys: Set[Text]=None, tree=None
    ) -> 'Query':
        """
        Create a Query from a list of dotted field paths.
        """
        query = Query(biz_type)

        if tree is None:
            assert keys
            tree = DictUtils.unflatten_keys({k: None for k in keys})

        if '*' in tree:
            del tree['*']
            tree.update({
                k: None for k, v in biz_type.schema.fields.items()
                if not v.meta.get('private', False)
            })
        elif not tree:
            tree = {'_id': None, '_rev': None}

        for k, v in tree.items():
            if isinstance(v, dict):
                rel = biz_type.relationships[k]
                sub_query = cls.from_keys(rel.target_biz_type, tree=v)
                sub_query.alias = rel.name
                query._add_target(sub_query, None)
            else:
                query._add_target(k, v)

        return query


class AbstractQuery(object):
    def __init__(self, alias: Text = None):
        self._alias = alias

    @property
    def alias(self) -> Text:
        return self._alias

    @alias.setter
    def alias(self, alias):
        if self._alias is not None:
            raise ValueError('alias is readonly')
        self._alias = alias

    def execute(self, source: 'BizObject'):
        raise NotImplementedError('override in subclass')


class Query(AbstractQuery):
    """
    query = (
        User.select(
            User.account.select(Account.name)
            User.email
        ).where(
            User.age > 14
        ).orderby(
            User.email.desc
        ).limit(1)
    )
    """

    class Parameters(object):
        def __init__(
            self,
            fields=None
            attributes=None,
            sub_queries=None,
            order_by=None,
            where=None,
            limit=None,
            offset=None,
        ):
            self.fields = fields or {'_id': None, '_rev': None}
            self.attributes = attributes or {}
            self.sub_queries = sub_queries or {}
            self.order_by = order_by or tuple()
            self.where = where or None,
            self.limit = None
            self.offset = None


    _loader = QueryLoader()
    _executor = QueryExecutor()
    _printer  = QueryPrinter()

    def __init__(self, biz_type: Type['BizType'], alias: Text = None):
        super().__init__(alias=alias)

        self._biz_type = biz_type
        self._params = Query.Parameters()

        # by default, select at least all fields used by any relationship
        # declared on the biz_type.
        self._params.fields.update({
            f.name: None for f in biz_type.schema.fields.values()
            if (f.meta.get('pybiz_is_fk', False) or f.required)
        })

    def __getitem__(self, key):
        return getattr(self._params, key)

    def __setitem__(self, key, value):
        return setattr(self._params, key, value)

    def __repr__(self):
        biz_type_name = self.biz_type.__name__ if self.biz_type else ''
        if self.alias:
            alias_substr = f', alias="{self.alias}"'
        else:
            alias_substr = ''
        return f'<Query({biz_type_name}{alias_substr})>'

    def execute(self, first=False):
        targets = self._executor.execute(query=self)
        if first:
            return targets[0] if targets else None
        else:
            return targets

    def select(self, *targets: Tuple, append=True) -> 'Query':
        if not append:
            self._params.fields.clear()
            self._params.sub_queries.clear()
            self._params.attributes.clear()
        self._add_targets(targets)
        return self

    def where(self, *predicates: 'Predicate', append=True) -> 'Query':
        """
        Append or replace "where"-expression Predicates.
        """
        if predicates is None:
            self._params.where = None
        else:
            additional_predicates = []
            for obj in predicates:
                if is_sequence(obj):
                    additional_predicates.extend(obj)
                else:
                    additional_predicates.append(obj)
            additional_predicates = tuple(additional_predicates)
            if self._params.where is None:
                self._params.where = tuple()
            if append:
                self._params.where += additional_predicates
            else:
                self._params.where = additional_predicates
        return self

    def limit(self, limit: int) -> 'Query':
        """
        Set or re-set the Query limit int, for pagination. Used in convert with
        offset.
        """
        self._params.limit = max(limit, 1) if limit is not None else None
        return self

    def offset(self, offset: int) -> 'Query':
        """
        Set or re-set the Query offset int, for pagination, used in conjunction
        with limit.
        """
        self._params.offset = max(0, offset) if offset is not None else None
        return self

    def order_by(self, *order_by) -> 'Query':
        order_by_flattened = []
        for obj in order_by:
            if is_sequence(obj):
                order_by_flattened.extend(obj)
            else:
                order_by_flattened.append(obj)
        order_by_flattened = tuple(order_by_flattened)
        self._params.order_by = order_by_flattened
        return self

    def show(self):
        self._printer.print_query(query=self)

    def dump(self) -> Dict:
        return self._loader.dump(self)

    @classmethod
    def load(cls, biz_type: Type['BizObject'], data: Dict) -> 'Query':
        return cls._loader.load(biz_type, data)

    @classmethod
    def from_keys(cls, biz_type: Type['BizObject'], keys: Set[Text] = None):
        if not keys:
            keys = biz_type.schema.fields.keys()
        return cls._loader.from_keys(biz_type, keys=keys)

    @classmethod
    def from_graphql(cls, biz_type: Type['BizObject'], query: Text) -> 'Query':
        executor = graphql.GraphQLExecutor(biz_type)
        return executor.query(query, execute=False)

    @property
    def biz_type(self) -> Type['BizObject']:
        return self._biz_type

    @property
    def params(self) -> Parameters:
        return self._params

    def _add_targets(self, targets):
        for obj in targets:
            if is_sequence(obj):
                self._add_targets(obj)
            elif isinstance(obj, dict):
                for k, v in obj.items():
                    self._add_target(k, v)
            else:
                self._add_target(obj, None)

    def _add_target(self, target, params):
        """
        Add a new query target to this Query. A target can be a FieldProperty,
        RelationshipProperty, ViewProperty, or more generically, any
        BizAttribute declared on self.biz_type, the targeted BizObject class.
        The target can also just be the string name of one of these things.
        Finally, a target can also be an already-formed Query object.
        """
        key = None
        targets = None
        params = params if params is not None else {}

        # resolve pybiz type from string target variable
        try:
            if isinstance(target, str):
                target = getattr(self._biz_type, target)
        except AttributeError:
            raise AttributeError(
                f'{self._biz_type} has no attribute "{target}"'
            )

        # add the target to the appropriate collection
        if isinstance(target, FieldProperty):
            assert target.biz_attr is self.biz_type
            key = target.field.name
            targets = self._params.fields
        elif isinstance(target, BizAttributeProperty):
            assert target.biz_attr.biz_type is self.biz_type
            biz_attr = target.biz_attr
            key = biz_attr.name
            targets = self._params.attributes
            if biz_attr.category == 'relationship':
                params = Query.from_keys(biz_type=biz_attr.target_biz_type)
        elif isinstance(target, BizAttributeQuery):
            assert target.biz_type is self.biz_type
            key = target.alias
            targets = self._params.attributes
            params = target
        elif isinstance(target, Query):
            assert target.biz_type is self.biz_type
            key = target.alias
            targets = self._params.attributes
            params = target

        if targets is not None:
            targets[key] = params


class BizAttributeQuery(AbstractQuery):

    class Assignment(object):
        def __init__(self, name: Text, query: 'BizAttributeQuery'):
            self.name = name
            self.query = query

        def __call__(self, value):
            self.query._params[self.name] = value
            return self.query


    def __init__(self, biz_attr: 'BizAttribute', alias=None, *args, **kwargs):
        super().__init__(alias=alias)
        self._biz_attr = biz_attr
        self._params = {}

    def __repr__(self):
        biz_type_name = (
            self._biz_attr.biz_type.__name__
            if self.biz_attr else ''
        )
        if self.alias:
            alias_substr = f', alias="{self.alias}"'
        else:
            alias_substr = ''

        return f'<BizAttributeQuery({biz_type_name}{alias_substr})>'

    def __getattr__(self, param_name):
        """
        This is so you can do query.foo('bar'), resulting in a 'bar': 'foo'
        entry in query._params.
        """
        return BizAttributeQuery.Assignment(param_name, self)

    @property
    def biz_attr(self) -> 'BizAttribute':
        return self._biz_attr

    @property
    def params(self) -> Dict:
        return self._params

    def execute(self, source: 'BizObject'):
        return self._biz_attr.execute(source, **self._params)
